{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to complex analysis course. \u00b6 This is the course page of complex analysis course taught in university department of mathematics, Tilka Manjhi Bhagalpur University, Bhagalpur. Syllabus \u00b6 Instructor \u00b6 Sandeep Suman, Assistant Professor, TMBU, Bhagalpur","title":"Home"},{"location":"#welcome-to-complex-analysis-course","text":"This is the course page of complex analysis course taught in university department of mathematics, Tilka Manjhi Bhagalpur University, Bhagalpur.","title":"Welcome to complex analysis course."},{"location":"#syllabus","text":"","title":"Syllabus"},{"location":"#instructor","text":"Sandeep Suman, Assistant Professor, TMBU, Bhagalpur","title":"Instructor"},{"location":"Function/","text":"After learning about complex numbers, now we are in position to learn about functions that map complex numbers to complex number, i.e., f: \\mathbb{C} \\to \\mathbb{C} . If z=x+iy , then f can be written as \\begin{align} f(z=x+iy) &= u(x,y)+iv(x,y) \\end{align} Where u,v:\\mathbb{R}^2 \\to \\mathbb{R} , u is called the real part and v is called the imaginary part of a complex valued funcion f . import sympy as sp sp . init_printing () x , y , z = sp . symbols ( \"x y z\" ) z = x + 1j * y f = sp . Function ( \"f\" ) f = z ** 2 # Lambda(z, z**2) sp . collect ( f . expand (), 1j ) x^{2} + 2.0 i x y - 1.0 y^{2} from plotly.offline import init_notebook_mode , iplot from IPython.display import display , HTML import numpy as np init_notebook_mode ( connected = True ) t = np . linspace ( - 1 , 1 , 100 ) x = t + t ** 2 y = t - t ** 2 xm = np . min ( x ) - 1.5 xM = np . max ( x ) + 1.5 ym = np . min ( y ) - 1.5 yM = np . max ( y ) + 1.5 N = 50 s = np . linspace ( - 1 , 1 , N ) xx = s + s ** 2 yy = s - s ** 2 data = [ dict ( x = x , y = y , mode = 'lines' , line = dict ( width = 2 , color = 'blue' ) ), dict ( x = x , y = y , mode = 'lines' , line = dict ( width = 2 , color = 'blue' ) ) ] layout = dict ( xaxis = dict ( range = [ xm , xM ], autorange = False , zeroline = False ), yaxis = dict ( range = [ ym , yM ], autorange = False , zeroline = False ), title = 'Kinematic Generation of a Planar Curve' , hovermode = 'closest' , updatemenus = [{ 'type' : 'buttons' , 'buttons' : [{ 'label' : 'Play' , 'method' : 'animate' , 'args' : [ None ]}]}]) frames = [ dict ( data = [ dict ( x = [ xx [ k ]], y = [ yy [ k ]], mode = 'markers' , marker = dict ( color = 'red' , size = 10 ) ) ]) for k in range ( N )] figure1 = dict ( data = data , layout = layout , frames = frames ) iplot ( figure1 ) window.PlotlyConfig = {MathJaxConfig: 'local'}; if (window.MathJax) {MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});} requirejs.config({paths: { 'plotly': ['https://cdn.plot.ly/plotly-latest.min']},});if(!window._Plotly) {require(['plotly'],function(plotly) {window._Plotly=plotly;});} require([\"plotly\"], function(Plotly) { window.PLOTLYENV=window.PLOTLYENV || {};window.PLOTLYENV.BASE_URL=\"https://plot.ly\"; if (document.getElementById(\"1c4dd15c-a65a-4200-b734-72c928fb1733\")) { Plotly.plot( '1c4dd15c-a65a-4200-b734-72c928fb1733', [{\"line\": {\"color\": \"blue\", \"width\": 2}, \"mode\": \"lines\", \"x\": [0.0, -0.01979389858177738, -0.03877155392306908, -0.0569329660238751, -0.07427813488419543, -0.0908070605040302, -0.10651974288337929, -0.12141618202224269, -0.13549637792062041, -0.14876033057851246, -0.16120803999591882, -0.1728395061728395, -0.1836547291092746, -0.19365370880522392, -0.20283644526068767, -0.21120293847566574, -0.21875318845015818, -0.22548719518416488, -0.23140495867768596, -0.23650647893072135, -0.24079175594327112, -0.24426078971533516, -0.24691358024691357, -0.24875012753800635, -0.2497704315886134, -0.24997449239873482, -0.24936230996837058, -0.24793388429752067, -0.24568921538618507, -0.24262830323436385, -0.23875114784205692, -0.23405774920926437, -0.22854810733598613, -0.2222222222222222, -0.2150800938679726, -0.20712172227323739, -0.19834710743801653, -0.18875624936230995, -0.1783491480461177, -0.1671258034894398, -0.15508621569227624, -0.142230384654627, -0.12855831037649218, -0.11406999285787162, -0.09876543209876538, -0.08264462809917349, -0.06570758085909592, -0.047954290378532695, -0.029384756657483906, -0.009998979695949348, 0.010203040506070876, 0.031221303948576883, 0.05305581063156832, 0.07570656055504542, 0.09917355371900843, 0.12345679012345685, 0.1485562697683912, 0.17447199265381094, 0.20120395877971636, 0.22875216814610771, 0.2571166207529844, 0.28629731660034713, 0.3162942556881952, 0.3471074380165292, 0.37873686358534864, 0.41118253239465363, 0.4444444444444447, 0.47852259973472105, 0.5134169982654835, 0.5491276400367311, 0.5856545250484648, 0.6229976533006838, 0.6611570247933884, 0.7001326395265792, 0.7399244975002552, 0.7805325987144174, 0.8219569431690646, 0.8641975308641976, 0.9072543617998167, 0.951127435975921, 0.9958167533925114, 1.041322314049587, 1.0876441179471488, 1.1347821650851957, 1.1827364554637283, 1.2315069890827472, 1.281093765942251, 1.331496786042241, 1.3827160493827164, 1.4347515559636779, 1.4876033057851243, 1.5412712988470565, 1.595755535149475, 1.6510560146923785, 1.7071727374757684, 1.7641057034996432, 1.8218549127640038, 1.8804203652688507, 1.9398020610141824, 2.0], \"y\": [-2.0, -1.9398020610141822, -1.88042036526885, -1.8218549127640038, -1.764105703499643, -1.707172737475768, -1.6510560146923783, -1.5957555351494745, -1.5412712988470563, -1.487603305785124, -1.4347515559636772, -1.382716049382716, -1.3314967860422406, -1.2810937659422508, -1.2315069890827466, -1.1827364554637283, -1.1347821650851952, -1.0876441179471483, -1.0413223140495869, -0.9958167533925109, -0.9511274359759208, -0.9072543617998162, -0.8641975308641976, -0.8219569431690641, -0.7805325987144169, -0.739924497500255, -0.7001326395265788, -0.6611570247933882, -0.6229976533006835, -0.5856545250484644, -0.5491276400367309, -0.513416998265483, -0.47852259973472083, -0.4444444444444443, -0.41118253239465347, -0.37873686358534825, -0.3471074380165289, -0.316294255688195, -0.2862973166003468, -0.25711662075298425, -0.2287521681461074, -0.2012039587797162, -0.1744719926538108, -0.14855626976839093, -0.12345679012345671, -0.09917355371900817, -0.0757065605550453, -0.05305581063156808, -0.031221303948576647, -0.010203040506070762, 0.009998979695949456, 0.029384756657484114, 0.047954290378532896, 0.06570758085909602, 0.08264462809917367, 0.09876543209876547, 0.11406999285787178, 0.12855831037649226, 0.14223038465462706, 0.15508621569227637, 0.16712580348943987, 0.17834914804611784, 0.18875624936231, 0.19834710743801662, 0.20712172227323747, 0.21508009386797267, 0.22222222222222227, 0.22854810733598613, 0.23405774920926442, 0.23875114784205695, 0.24262830323436388, 0.2456892153861851, 0.24793388429752067, 0.24936230996837058, 0.24997449239873482, 0.2497704315886134, 0.2487501275380063, 0.24691358024691357, 0.24426078971533516, 0.24079175594327107, 0.2365064789307213, 0.2314049586776859, 0.22548719518416482, 0.21875318845015812, 0.21120293847566574, 0.20283644526068756, 0.19365370880522392, 0.1836547291092745, 0.17283950617283939, 0.1612080399959186, 0.14876033057851235, 0.1354963779206203, 0.12141618202224247, 0.10651974288337918, 0.09080706050402998, 0.07427813488419532, 0.0569329660238751, 0.03877155392306886, 0.01979389858177727, 0.0], \"type\": \"scatter\", \"uid\": \"29032c89-576a-4f59-86e9-204930ade71f\"}, {\"line\": {\"color\": \"blue\", \"width\": 2}, \"mode\": \"lines\", \"x\": [0.0, -0.01979389858177738, -0.03877155392306908, -0.0569329660238751, -0.07427813488419543, -0.0908070605040302, -0.10651974288337929, -0.12141618202224269, -0.13549637792062041, -0.14876033057851246, -0.16120803999591882, -0.1728395061728395, -0.1836547291092746, -0.19365370880522392, -0.20283644526068767, -0.21120293847566574, -0.21875318845015818, -0.22548719518416488, -0.23140495867768596, -0.23650647893072135, -0.24079175594327112, -0.24426078971533516, -0.24691358024691357, -0.24875012753800635, -0.2497704315886134, -0.24997449239873482, -0.24936230996837058, -0.24793388429752067, -0.24568921538618507, -0.24262830323436385, -0.23875114784205692, -0.23405774920926437, -0.22854810733598613, -0.2222222222222222, -0.2150800938679726, -0.20712172227323739, -0.19834710743801653, -0.18875624936230995, -0.1783491480461177, -0.1671258034894398, -0.15508621569227624, -0.142230384654627, -0.12855831037649218, -0.11406999285787162, -0.09876543209876538, -0.08264462809917349, -0.06570758085909592, -0.047954290378532695, -0.029384756657483906, -0.009998979695949348, 0.010203040506070876, 0.031221303948576883, 0.05305581063156832, 0.07570656055504542, 0.09917355371900843, 0.12345679012345685, 0.1485562697683912, 0.17447199265381094, 0.20120395877971636, 0.22875216814610771, 0.2571166207529844, 0.28629731660034713, 0.3162942556881952, 0.3471074380165292, 0.37873686358534864, 0.41118253239465363, 0.4444444444444447, 0.47852259973472105, 0.5134169982654835, 0.5491276400367311, 0.5856545250484648, 0.6229976533006838, 0.6611570247933884, 0.7001326395265792, 0.7399244975002552, 0.7805325987144174, 0.8219569431690646, 0.8641975308641976, 0.9072543617998167, 0.951127435975921, 0.9958167533925114, 1.041322314049587, 1.0876441179471488, 1.1347821650851957, 1.1827364554637283, 1.2315069890827472, 1.281093765942251, 1.331496786042241, 1.3827160493827164, 1.4347515559636779, 1.4876033057851243, 1.5412712988470565, 1.595755535149475, 1.6510560146923785, 1.7071727374757684, 1.7641057034996432, 1.8218549127640038, 1.8804203652688507, 1.9398020610141824, 2.0], \"y\": [-2.0, -1.9398020610141822, -1.88042036526885, -1.8218549127640038, -1.764105703499643, -1.707172737475768, -1.6510560146923783, -1.5957555351494745, -1.5412712988470563, -1.487603305785124, -1.4347515559636772, -1.382716049382716, -1.3314967860422406, -1.2810937659422508, -1.2315069890827466, -1.1827364554637283, -1.1347821650851952, -1.0876441179471483, -1.0413223140495869, -0.9958167533925109, -0.9511274359759208, -0.9072543617998162, -0.8641975308641976, -0.8219569431690641, -0.7805325987144169, -0.739924497500255, -0.7001326395265788, -0.6611570247933882, -0.6229976533006835, -0.5856545250484644, -0.5491276400367309, -0.513416998265483, -0.47852259973472083, -0.4444444444444443, -0.41118253239465347, -0.37873686358534825, -0.3471074380165289, -0.316294255688195, -0.2862973166003468, -0.25711662075298425, -0.2287521681461074, -0.2012039587797162, -0.1744719926538108, -0.14855626976839093, -0.12345679012345671, -0.09917355371900817, -0.0757065605550453, -0.05305581063156808, -0.031221303948576647, -0.010203040506070762, 0.009998979695949456, 0.029384756657484114, 0.047954290378532896, 0.06570758085909602, 0.08264462809917367, 0.09876543209876547, 0.11406999285787178, 0.12855831037649226, 0.14223038465462706, 0.15508621569227637, 0.16712580348943987, 0.17834914804611784, 0.18875624936231, 0.19834710743801662, 0.20712172227323747, 0.21508009386797267, 0.22222222222222227, 0.22854810733598613, 0.23405774920926442, 0.23875114784205695, 0.24262830323436388, 0.2456892153861851, 0.24793388429752067, 0.24936230996837058, 0.24997449239873482, 0.2497704315886134, 0.2487501275380063, 0.24691358024691357, 0.24426078971533516, 0.24079175594327107, 0.2365064789307213, 0.2314049586776859, 0.22548719518416482, 0.21875318845015812, 0.21120293847566574, 0.20283644526068756, 0.19365370880522392, 0.1836547291092745, 0.17283950617283939, 0.1612080399959186, 0.14876033057851235, 0.1354963779206203, 0.12141618202224247, 0.10651974288337918, 0.09080706050402998, 0.07427813488419532, 0.0569329660238751, 0.03877155392306886, 0.01979389858177727, 0.0], \"type\": \"scatter\", \"uid\": \"361cf763-036d-4e14-acc5-aafda48ee184\"}], {\"hovermode\": \"closest\", \"title\": {\"text\": \"Kinematic Generation of a Planar Curve\"}, \"updatemenus\": [{\"buttons\": [{\"args\": [null], \"label\": \"Play\", \"method\": \"animate\"}], \"type\": \"buttons\"}], \"xaxis\": {\"autorange\": false, \"range\": [-1.7499744923987348, 3.5], \"zeroline\": false}, \"yaxis\": {\"autorange\": false, \"range\": [-3.5, 1.7499744923987348], \"zeroline\": false}}, {\"showLink\": false, \"linkText\": \"Export to plot.ly\", \"plotlyServerURL\": \"https://plot.ly\"} ).then(function () {return Plotly.addFrames('1c4dd15c-a65a-4200-b734-72c928fb1733',[{\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.0], \"y\": [-2.0], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.03915035401915867], \"y\": [-1.8792169929196167], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.07496876301541022], \"y\": [-1.7617659308621407], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.10745522698875476], \"y\": [-1.6476468138275717], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.13660974593919195], \"y\": [-1.5368596418159102], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.16243231986672224], \"y\": [-1.4294044148271552], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.1849229487713453], \"y\": [-1.3252811328613077], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.20408163265306123], \"y\": [-1.2244897959183674], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.21990837151187004], \"y\": [-1.1270304039983343], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.23240316534777178], \"y\": [-1.0329029571012078], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.24156601416076634], \"y\": [-0.9421074552269888], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.24739691795085378], \"y\": [-0.854643898375677], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.24989587671803415], \"y\": [-0.770512286547272], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.24906289046230737], \"y\": [-0.6897126197417744], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.24489795918367346], \"y\": [-0.6122448979591837], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.23740108288213246], \"y\": [-0.5381091211995004], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.2265722615576843], \"y\": [-0.467305289462724], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.21241149521032904], \"y\": [-0.39983340274885465], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.19491878384006667], \"y\": [-0.33569346105789266], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.17409412744689715], \"y\": [-0.27488546438983763], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.14993752603082056], \"y\": [-0.21740941274468983], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.12244897959183677], \"y\": [-0.16326530612244905], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.09162848812994595], \"y\": [-0.1124531445231155], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.057476051645147914], \"y\": [-0.06497292794668895], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [-0.019991670137442755], \"y\": [-0.020824656393169536], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.020824656393169536], \"y\": [0.019991670137442755], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.06497292794668871], \"y\": [0.05747605164514772], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.11245314452311524], \"y\": [0.09162848812994577], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.16326530612244888], \"y\": [0.12244897959183669], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.2174094127446897], \"y\": [0.14993752603082047], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.2748854643898373], \"y\": [0.174094127446897], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.33569346105789233], \"y\": [0.19491878384006656], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.3998334027488545], \"y\": [0.21241149521032898], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.46730528946272376], \"y\": [0.22657226155768428], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.5381091211995002], \"y\": [0.23740108288213244], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.6122448979591834], \"y\": [0.24489795918367344], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.689712619741774], \"y\": [0.24906289046230737], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.7705122865472718], \"y\": [0.24989587671803415], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.8546438983756767], \"y\": [0.24739691795085383], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [0.9421074552269882], \"y\": [0.2415660141607664], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.0329029571012074], \"y\": [0.23240316534777183], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.1270304039983337], \"y\": [0.2199083715118701], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.2244897959183672], \"y\": [0.20408163265306123], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.3252811328613077], \"y\": [0.1849229487713453], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.4294044148271547], \"y\": [0.16243231986672235], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.5368596418159095], \"y\": [0.13660974593919217], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.6476468138275715], \"y\": [0.10745522698875476], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.7617659308621405], \"y\": [0.07496876301541033], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [1.8792169929196167], \"y\": [0.03915035401915867], \"type\": \"scatter\"}]}, {\"data\": [{\"marker\": {\"color\": \"red\", \"size\": 10}, \"mode\": \"markers\", \"x\": [2.0], \"y\": [0.0], \"type\": \"scatter\"}]}]);}).then(function(){Plotly.animate('1c4dd15c-a65a-4200-b734-72c928fb1733');}) } }); window.addEventListener(\"resize\", function(){if (document.getElementById(\"1c4dd15c-a65a-4200-b734-72c928fb1733\")) {window._Plotly.Plots.resize(document.getElementById(\"1c4dd15c-a65a-4200-b734-72c928fb1733\"));};}) Now we try to visualize some of the functions in complex domain. Visualizing complex functions are not easy because it require 4- dimensional space to plot a complex functions, and most of us can't visualize 4- dimensional space. Other way is to look at the image different shapes of complex plane under these mappings. Here we look at the image of a square region [1,3]\\times[1,3] under some common mapping. % matplotlib inline import numpy as np import matplotlib.pyplot as plt def fun_plot ( f ): u = np . linspace ( 0 , 3 , 80 ) v = np . linspace ( 0 , 3 , 80 ) uu , vv = np . meshgrid ( u , v ) z0 = uu + 1j * vv z = f ( z0 ) T = np . arctan2 ( uu , vv ) plt . scatter ( np . real ( z ), np . imag ( z ), c = T , s = 10 , lw = 0 ) plt . xlabel ( 'Re(z)' ) plt . ylabel ( 'Im(z)' ) plt . grid ( True ) plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ) plt . title ( 'Original Square' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z * ( 2 + 3 * 1j )) plt . title ( '$f(z)=(2+3i)z$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ** 2 ) plt . title ( '$f(z)=z^2$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z ** 3 ) plt . title ( '$f(z)=z^3$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ** 4 ) plt . title ( '$f(z)=z^4$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z ** 5 ) plt . title ( '$f(z)=z^5$' ) plt . gray plt . show () from numpy import sin , cos , tan , exp , log plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( sin ) plt . title ( '$f(z)=\\sin \\,z$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( cos ) plt . title ( '$f(z)=\\cos \\,z$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( tan ) plt . title ( '$f(z)=tan \\,z$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : 1 / tan ( z + 1 )) plt . title ( '$f(z)=\\cot \\,(z+1)$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( exp ) plt . title ( '$f(z)=e^z$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : log ( z + 1 )) plt . title ( '$f(z)=\\log(z+1)$' ) plt . gray plt . show () from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm from matplotlib.ticker import LinearLocator , FormatStrFormatter import matplotlib.pyplot as plt # the function that I'm going to plot def z_func ( x , y ): return ( 1 - ( x ** 2 + y ** 3 )) * exp ( - ( x ** 2 + y ** 2 ) / 2 ) x = arange ( - 3.0 , 3.0 , 0.1 ) y = arange ( - 3.0 , 3.0 , 0.1 ) X , Y = meshgrid ( x , y ) # grid of point Z = z_func ( X , Y ) # evaluation of the function on the grid fig = plt . figure () ax = fig . gca ( projection = '3d' ) surf = ax . plot_surface ( X , Y , Z , rstride = 1 , cstride = 1 , cmap = cm . RdBu , linewidth = 0 , antialiased = False ) ax . zaxis . set_major_locator ( LinearLocator ( 10 )) ax . zaxis . set_major_formatter ( FormatStrFormatter ( ' %.02f ' )) fig . colorbar ( surf , shrink = 0.5 , aspect = 5 ) plt . show () from numpy import exp , arange from pylab import meshgrid , cm , imshow , contour , clabel , colorbar , axis , title , show # the function that I'm going to plot def z_func ( x , y ): return ( 1 - ( x ** 2 + y ** 3 )) * exp ( - ( x ** 2 + y ** 2 ) / 2 ) x = arange ( - 3.0 , 3.0 , 0.1 ) y = arange ( - 3.0 , 3.0 , 0.1 ) X , Y = meshgrid ( x , y ) # grid of point Z = z_func ( X , Y ) # evaluation of the function on the grid im = imshow ( Z , cmap = cm . RdBu ) # drawing the function # adding the Contour lines with labels cset = contour ( Z , arange ( - 1 , 1.5 , 0.2 ), linewidths = 2 , cmap = cm . Set2 ) clabel ( cset , inline = True , fmt = ' %1.1f ' , fontsize = 10 ) colorbar ( im ) # adding the colobar on the right # latex fashion title title ( '$z=(1-x^2+y^3) e^{-(x^2+y^2)/2}$' ) show () from mpmath import * cplot ( lambda z : z , [ - 10 , 10 ], [ - 10 , 10 ]) cplot ( lambda z : z ** 2 , [ - 10 , 10 ], [ - 10 , 10 ]) cplot ( exp , [ - 10 , 10 ], [ - 10 , 10 ]) cplot ( zeta , [ 0 , 50 ], [ 0 , 50 ])","title":"Function"},{"location":"Integration/","text":"from sympy import * init_printing () import sympy.vector as sv x , y , z , t = symbols ( 'x y z t' ) R = sv . CoordSys3D ( 'R' ) def v ( x , y , z ): # vector field as a function of scalar variables x,y,z return x * y * R . i + 2 * y * z * R . j + 3 * x * z * R . k def voft ( l ): # vector field along path l as a function of t x , y , z = ( l . dot ( R . i ), l . dot ( R . j ), l . dot ( R . k )) # x,y,z as functions of t return v ( x , y , z ) def li ( l , v ): # dl/dt dl = diff ( l , t ) return integrate ( voft ( l ) . dot ( dl ),( t , 0 , 1 )) l1 = 2 * t * R . j l2 = 2 * ( 1 - t ) * R . j + 2 * t * R . k l3 = 2 * ( 1 - t ) * R . k li ( l1 , v ), li ( l2 , v ), li ( l3 , v ) \\left ( 0, \\quad - \\frac{8}{3}, \\quad 0\\right ) l1 , l2 , l3 \\left ( (2 t)\\mathbf{\\hat{j}_{R}}, \\quad (- 2 t + 2)\\mathbf{\\hat{j}_{R}} + (2 t)\\mathbf{\\hat{k}_{R}}, \\quad (- 2 t + 2)\\mathbf{\\hat{k}_{R}}\\right ) dl1 = diff ( l1 , t ) dl2 = diff ( l2 , t ) dl3 = diff ( l3 , t ) dl1 , dl2 , dl3 \\left ( (2)\\mathbf{\\hat{j}_{R}}, \\quad (-2)\\mathbf{\\hat{j}_{R}} + (2)\\mathbf{\\hat{k}_{R}}, \\quad (-2)\\mathbf{\\hat{k}_{R}}\\right ) voft ( l1 ), voft ( l2 ), voft ( l3 ) \\left ( \\mathbf{\\hat{0}}, \\quad (2 t \\left(- 4 t + 4\\right))\\mathbf{\\hat{j}_{R}}, \\quad \\mathbf{\\hat{0}}\\right ) voft ( l1 ) . dot ( l1 ), voft ( l2 ) . dot ( l2 ), voft ( l3 ) . dot ( l3 ) \\left ( 0, \\quad 2 t \\left(- 4 t + 4\\right) \\left(- 2 t + 2\\right), \\quad 0\\right ) integrate ( voft ( l2 ) . dot ( dl2 ),( t , 0 , 1 )) - \\frac{8}{3} A contour is a finite collection of paths joined end to end. A path can be represented as a continuous function form an closed iterval to \\mathbb{C} as follows \\gamma: [a~ b]\\subset \\mathbb{R} \\to \\mathbb{C}; \\quad \\gamma = \\gamma(t) Then the integration of any complex function along this path is is given by \\int_\\gamma f(z)dz = \\int_a^b f(t)~\\gamma'(t)~dt = \\sum_{i=1}^n f(t_i) \\left[\\gamma(t_i)-\\gamma(t_{i-1})\\right] Question: Find the integration of f(z)=z^2 along the parabolic path from 0 to 1 . Answer: In order to find the integration we have to find to parametrize the curve as \\gamma(t)=t+t^2i , t\\in [0,1] . % matplotlib inline import numpy as np from matplotlib import pyplot as plt x , y , t = symbols ( \"x y t\" ) def \u03b3 ( t ): return t + t ** 2 * 1j def f ( z ): return z * z # arr = np.linspace(0, 1, 10) # cnums = [\u03b3(t) for t in arr] # imgs = [f(z) for z in cnums] arr = np . linspace ( 0 , 1 , 10 ) # Y = np.linspace(0, 1, 10) X , Y = np . meshgrid ( arr , arr ) U = X ** 2 - Y ** 2 V = 2 * X * Y plt . quiver ( X , Y , U , V , edgecolor = 'k' , facecolor = 'None' , linewidth =. 5 ) cnums = np . array ( list ( map ( \u03b3 , arr ))) imgs = np . array ( list ( map ( f , cnums ))) X_0 = list ( map ( lambda z : z . real , cnums )) Y_0 = list ( map ( lambda z : z . imag , cnums )) U_0 = list ( map ( lambda z : z . real , imgs )) V_0 = list ( map ( lambda z : z . imag , imgs )) plt . plot ( X_0 , Y_0 , color = 'blue' ) plt . scatter ( X_0 , Y_0 , color = 'red' ) plt . quiver ( X_0 , Y_0 , U_0 , V_0 ) plt . show () # [(f(x+1j*y).real, f(x+1j*y).imag) for x in X for y in Y ] Here we will do the numerical computation \u0394 t = cnums [ 1 :] - cnums [: - 1 ] np . dot ( imgs [ 1 :], \u0394 t ) (-0.6818686799806022+0.675438053988273j) Now we do the same computation using integration integrate ( f ( \u03b3 ( t )) * diff ( \u03b3 ( t ), t ),( t , 0 , 1 )) -0.666666666666667 + 0.666666666666667 i import numpy as np from matplotlib import pyplot as plt from matplotlib import animation X , Y = np . mgrid [: 2 * np . pi : 10j ,: 2 * np . pi : 5j ] U = np . cos ( X ) V = np . sin ( Y ) fig , ax = plt . subplots ( 1 , 1 ) Q = ax . quiver ( X , Y , U , V , pivot = 'mid' , color = 'r' , units = 'inches' ) ax . set_xlim ( - 1 , 7 ) ax . set_ylim ( - 1 , 7 ) def update_quiver ( num , Q , X , Y ): \"\"\"updates the horizontal and vertical vector components by a fixed increment on each frame \"\"\" U = np . cos ( X + num * 0.1 ) V = np . sin ( Y + num * 0.1 ) Q . set_UVC ( U , V ) return Q # you need to set blit=False, or the first set of arrows never gets # cleared on subsequent frames anim = animation . FuncAnimation ( fig , update_quiver , fargs = ( Q , X , Y ), interval = 50 , blit = False ) fig . tight_layout () plt . show () import plotly.plotly as py from plotly.grid_objs import Grid , Column import time column_1 = Column ([ 0.9 , 1.1 ], 'x' ) column_2 = Column ([ 1.0 , 1.0 ], 'y' ) column_3 = Column ([ 0.8 , 1.2 ], 'x2' ) column_4 = Column ([ 1.2 , 0.8 ], 'y2' ) column_5 = Column ([ 0.7 , 1.3 ], 'x3' ) column_6 = Column ([ 0.7 , 1.3 ], 'y3' ) column_7 = Column ([ 0.6 , 1.4 ], 'x4' ) column_8 = Column ([ 1.5 , 0.5 ], 'y4' ) column_9 = Column ([ 0.4 , 1.6 ], 'x5' ) column_10 = Column ([ 1.2 , 0.8 ], 'y5' ) grid = Grid ([ column_1 , column_2 , column_3 , column_4 , column_5 , column_6 , column_7 , column_8 , column_9 , column_10 ]) py . grid_ops . upload ( grid , 'points_changing_size_grid' + str ( time . time ()), auto_open = False ) # create figure figure = { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x' ), 'ysrc' : grid . get_column_reference ( 'y' ), 'mode' : 'markers' , 'marker' : { 'color' : '#48186a' , 'size' : 10 } } ], 'layout' : { 'title' : 'Growing Circles' , 'xaxis' : { 'range' : [ 0 , 2 ], 'autorange' : False }, 'yaxis' : { 'range' : [ 0 , 2 ], 'autorange' : False }, 'updatemenus' : [{ 'buttons' : [ { 'args' : [ None ], 'label' : 'Play' , 'method' : 'animate' } ], 'pad' : { 'r' : 10 , 't' : 87 }, 'showactive' : False , 'type' : 'buttons' }]}, 'frames' : [ { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x2' ), 'ysrc' : grid . get_column_reference ( 'y2' ), 'mode' : 'markers' , 'marker' : { 'color' : '#3b528b' , 'size' : 25 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x3' ), 'ysrc' : grid . get_column_reference ( 'y3' ), 'mode' : 'markers' , 'marker' : { 'color' : '#26828e' , 'size' : 50 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x4' ), 'ysrc' : grid . get_column_reference ( 'y4' ), 'mode' : 'markers' , 'marker' : { 'color' : '#5ec962' , 'size' : 80 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x5' ), 'ysrc' : grid . get_column_reference ( 'y5' ), 'mode' : 'markers' , 'marker' : { 'color' : '#d8e219' , 'size' : 100 } } ] } ] } py . icreate_animations ( figure , 'points_changing_size' + str ( time . time ())) import plotly plotly . __version__ '3.7.0'","title":"Definition"},{"location":"Introduction/","text":"In this section we will define complex numbers as an extension of \\mathbb{R} as the following \\mathbb{C} \\cong \\mathbb{R}[x] / \\langle x^2+1 \\rangle = \\{a+bx+\\langle x^2+1 \\rangle\\ | ~ a,b \\in \\mathbb{R} \\} from sympy import * init_printing () a , b , c , d = symbols ( \"a b c d\" ) x , y = symbols ( \"x y\" ) Algebra of Complex Number \u00b6 Addition of two complex numbers are done as follows ad = ( a + b * x ) + ( c + d * x ) Eq ( ad , collect ( ad , x )) a + b x + c + d x = a + c + x \\left(b + d\\right) Multiplication is done as follows mul = ( a + b * x ) * ( c + d * x ) Eq ( mul , expand ( mul )) \\left(a + b x\\right) \\left(c + d x\\right) = a c + a d x + b c x + b d x^{2} irr = x ** 2 + 1 quo , rem = pdiv ( mul , irr ) collect ( rem , x ) a c - b d + x \\left(a d + b c\\right)","title":"Definition"},{"location":"Introduction/#algebra-of-complex-number","text":"Addition of two complex numbers are done as follows ad = ( a + b * x ) + ( c + d * x ) Eq ( ad , collect ( ad , x )) a + b x + c + d x = a + c + x \\left(b + d\\right) Multiplication is done as follows mul = ( a + b * x ) * ( c + d * x ) Eq ( mul , expand ( mul )) \\left(a + b x\\right) \\left(c + d x\\right) = a c + a d x + b c x + b d x^{2} irr = x ** 2 + 1 quo , rem = pdiv ( mul , irr ) collect ( rem , x ) a c - b d + x \\left(a d + b c\\right)","title":"Algebra of Complex Number"},{"location":"Plotting/","text":"% matplotlib inline import matplotlib.pyplot as plt from numpy import * ''' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~` This draws the axis for argand diagram ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~` ''' r = 1 # Y = [r*exp(1j*theta) for theta in linspace(0,2*pi, 200)] # Y = array(Y) # plt.plot(real(Y), imag(Y), 'r') plt . ylabel ( 'Imaginary' ) plt . xlabel ( 'Real' ) plt . axhline ( y = 0 , color = 'black' ) plt . axvline ( x = 0 , color = 'black' ) def argand ( complex_number , vector = False ): ''' This function takes a complex number. ''' z = complex_number x = real ( y ) y = imag ( y ) plt . plot ( x , y , 'bo' ) if vector : plt . quiver ( 0 , 0 , x , y ) # Draw the hypotenuse # plt.plot(x2,y2, 'r') # Draw the projection on real-axis plt . plot ( x , imag ( y ), 'bo' ) [ argand ( r * exp ( 1j * theta ), vector = True ) for theta in linspace ( 0 , 2 * pi , 10 )] plt . show () --------------------------------------------------------------------------- UnboundLocalError Traceback (most recent call last) <ipython-input-40-501b6b9367ed> in <module>() 38 plt.plot(real(y), imag(y), 'bo') 39 ---> 40 [argand(r*exp(1j*theta), vector=True) for theta in linspace(0,2*pi,10)] 41 plt.show() <ipython-input-40-501b6b9367ed> in <listcomp>(.0) 38 plt.plot(real(y), imag(y), 'bo') 39 ---> 40 [argand(r*exp(1j*theta), vector=True) for theta in linspace(0,2*pi,10)] 41 plt.show() <ipython-input-40-501b6b9367ed> in argand(complex_number, vector) 24 ''' 25 z = complex_number ---> 26 x = real(y) 27 y = imag(y) 28 plt.plot(x,y, 'bo') UnboundLocalError: local variable 'y' referenced before assignment import matplotlib.pyplot as plt import numpy as np cnums = np . arange ( 5 ) + 1j * np . arange ( 6 , 11 ) X = [ x . real for x in cnums ] Y = [ x . imag for x in cnums ] plt . scatter ( X , Y , color = 'red' ) plt . show () a = [ 0. + 6.j , 1. + 7.j , 2. + 8.j , 3. + 9.j , 4. + 10.j ] for x in a : plt . polar ([ 0 , angle ( x )],[ 0 , abs ( x )], marker = 'o' ) Addition and Substraction \u00b6 import numpy as np import matplotlib.pyplot as plt soa = np . array ([[ 0 , 0 , 3 , 2 ], [ 0 , 0 , 1 , 2 ], [ 0 , 0 , 9 , 9 ]]) X , Y , U , V = zip ( * soa ) plt . figure () ax = plt . gca () ax . quiver ( X , Y , U , V , angles = 'xy' , scale_units = 'xy' , scale = 1 ) ax . set_xlim ([ - 1 , 10 ]) ax . set_ylim ([ - 1 , 10 ]) plt . draw () plt . show ()","title":"Plotting"},{"location":"Plotting/#addition-and-substraction","text":"import numpy as np import matplotlib.pyplot as plt soa = np . array ([[ 0 , 0 , 3 , 2 ], [ 0 , 0 , 1 , 2 ], [ 0 , 0 , 9 , 9 ]]) X , Y , U , V = zip ( * soa ) plt . figure () ax = plt . gca () ax . quiver ( X , Y , U , V , angles = 'xy' , scale_units = 'xy' , scale = 1 ) ax . set_xlim ([ - 1 , 10 ]) ax . set_ylim ([ - 1 , 10 ]) plt . draw () plt . show ()","title":"Addition and Substraction"}]}