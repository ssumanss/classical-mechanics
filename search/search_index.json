{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to complex analysis course. \u00b6 This is the course page of complex analysis course taught in university department of mathematics, Tilka Manjhi Bhagalpur University, Bhagalpur. Syllabus \u00b6 Instructor \u00b6 Sandeep Suman, Assistant Professor, TMBU, Bhagalpur","title":"Home"},{"location":"#welcome-to-complex-analysis-course","text":"This is the course page of complex analysis course taught in university department of mathematics, Tilka Manjhi Bhagalpur University, Bhagalpur.","title":"Welcome to complex analysis course."},{"location":"#syllabus","text":"","title":"Syllabus"},{"location":"#instructor","text":"Sandeep Suman, Assistant Professor, TMBU, Bhagalpur","title":"Instructor"},{"location":"Function/","text":"% matplotlib inline import numpy import sympy from mpl_toolkits.mplot3d import Axes3D import matplotlib from matplotlib import cm , colors from matplotlib import pyplot as plt branching_number = 2 Nr = 16 Ntheta = 32 # compute the theta,R domain theta = numpy . linspace ( 0 , 2 * numpy . pi * branching_number , Ntheta ) r = numpy . linspace ( 0 , 1 , Nr ) Theta , R = numpy . meshgrid ( theta , r ) z = R * numpy . exp ( 1j * Theta ) # compute w^2 = z. THE KEY IDEA is to pass the exponentiation by 1/2 into exp(). w = numpy . sqrt ( R ) * numpy . exp ( 1j * Theta / 2 ) # color by argument arguments = numpy . angle ( w ) norm = colors . Normalize ( arguments . min (), arguments . max ()) color = cm . jet ( norm ( arguments )) fig = plt . figure ( figsize = ( 16 , 8 )) # plot the real part ax_real = fig . add_subplot ( 1 , 2 , 1 , projection = '3d' ) ax_real . plot_surface ( z . real , z . imag , w . real , rstride = 1 , cstride = 1 , alpha = 0.5 , facecolors = color ) # plot the imaginary part ax_imag = fig . add_subplot ( 1 , 2 , 2 , projection = '3d' ) ax_imag . plot_surface ( z . real , z . imag , w . imag , rstride = 1 , cstride = 1 , alpha = 0.5 , facecolors = color ) plt . show () After learning about complex numbers, now we are in position to learn about functions that map complex numbers to complex number, i.e., f: \\mathbb{C} \\to \\mathbb{C} . If z=x+iy , then f can be written as \\begin{align} f(z=x+iy) &= u(x,y)+iv(x,y) \\end{align} Where u,v:\\mathbb{R}^2 \\to \\mathbb{R} , u is called the real part and v is called the imaginary part of a complex valued funcion f . import sympy as sp sp . init_printing () x , y , z = sp . symbols ( \"x y z\" ) z = x + 1j * y f = sp . Function ( \"f\" ) f = z ** 2 # Lambda(z, z**2) sp . collect ( f . expand (), 1j ) x^{2} + 2.0 i x y - 1.0 y^{2} # from sympy import Function, symbols # x, y = symbols(\"x y\") # f, g, h = map(Function, \"fgh\") # f = x % matplotlib inline import numpy as np import matplotlib.pyplot as plt def fun_plot ( f ): u = np . linspace ( 0 , 3 , 80 ) v = np . linspace ( 0 , 3 , 80 ) uu , vv = np . meshgrid ( u , v ) z0 = uu + 1j * vv z = f ( z0 ) T = np . arctan2 ( uu , vv ) plt . scatter ( np . real ( z ), np . imag ( z ), c = T , s = 10 , lw = 0 ) plt . xlabel ( 'Re(z)' ) plt . ylabel ( 'Im(z)' ) plt . grid ( True ) plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ) plt . title ( 'real points' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z * ( 2 + 3 * 1j )) plt . title ( 'real points' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ** 2 ) plt . title ( 'real points' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z ** 3 ) plt . title ( 'real points' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ** 4 ) plt . title ( 'real points' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z ** 5 ) plt . title ( 'real points' ) plt . gray plt . show () from numpy import sin , cos , tan , exp , log plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( sin ) plt . title ( 'real points' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( cos ) plt . title ( 'real points' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( tan ) plt . title ( 'real points' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z ** 3 ) plt . title ( 'real points' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( exp ) plt . title ( 'real points' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : log ( z + 1 )) plt . title ( 'real points' ) plt . gray plt . show () from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm from matplotlib.ticker import LinearLocator , FormatStrFormatter import matplotlib.pyplot as plt # the function that I'm going to plot def z_func ( x , y ): return ( 1 - ( x ** 2 + y ** 3 )) * exp ( - ( x ** 2 + y ** 2 ) / 2 ) x = arange ( - 3.0 , 3.0 , 0.1 ) y = arange ( - 3.0 , 3.0 , 0.1 ) X , Y = meshgrid ( x , y ) # grid of point Z = z_func ( X , Y ) # evaluation of the function on the grid fig = plt . figure () ax = fig . gca ( projection = '3d' ) surf = ax . plot_surface ( X , Y , Z , rstride = 1 , cstride = 1 , cmap = cm . RdBu , linewidth = 0 , antialiased = False ) ax . zaxis . set_major_locator ( LinearLocator ( 10 )) ax . zaxis . set_major_formatter ( FormatStrFormatter ( ' %.02f ' )) fig . colorbar ( surf , shrink = 0.5 , aspect = 5 ) plt . show () from numpy import exp , arange from pylab import meshgrid , cm , imshow , contour , clabel , colorbar , axis , title , show # the function that I'm going to plot def z_func ( x , y ): return ( 1 - ( x ** 2 + y ** 3 )) * exp ( - ( x ** 2 + y ** 2 ) / 2 ) x = arange ( - 3.0 , 3.0 , 0.1 ) y = arange ( - 3.0 , 3.0 , 0.1 ) X , Y = meshgrid ( x , y ) # grid of point Z = z_func ( X , Y ) # evaluation of the function on the grid im = imshow ( Z , cmap = cm . RdBu ) # drawing the function # adding the Contour lines with labels cset = contour ( Z , arange ( - 1 , 1.5 , 0.2 ), linewidths = 2 , cmap = cm . Set2 ) clabel ( cset , inline = True , fmt = ' %1.1f ' , fontsize = 10 ) colorbar ( im ) # adding the colobar on the right # latex fashion title title ( '$z=(1-x^2+y^3) e^{-(x^2+y^2)/2}$' ) show () from mpmath import * cplot ( lambda z : z , [ - 10 , 10 ], [ - 10 , 10 ]) cplot ( lambda z : z ** 2 , [ - 10 , 10 ], [ - 10 , 10 ]) cplot ( exp , [ - 10 , 10 ], [ - 10 , 10 ]) cplot ( zeta , [ 0 , 50 ], [ 0 , 50 ]) ! conda install - c conda - forge cplot % lsmagic","title":"Function"},{"location":"Integration/","text":"from sympy import * init_printing () import sympy.vector as sv x , y , z , t = symbols ( 'x y z t' ) R = sv . CoordSys3D ( 'R' ) def v ( x , y , z ): # vector field as a function of scalar variables x,y,z return x * y * R . i + 2 * y * z * R . j + 3 * x * z * R . k def voft ( l ): # vector field along path l as a function of t x , y , z = ( l . dot ( R . i ), l . dot ( R . j ), l . dot ( R . k )) # x,y,z as functions of t return v ( x , y , z ) def li ( l , v ): # dl/dt dl = diff ( l , t ) return integrate ( voft ( l ) . dot ( dl ),( t , 0 , 1 )) l1 = 2 * t * R . j l2 = 2 * ( 1 - t ) * R . j + 2 * t * R . k l3 = 2 * ( 1 - t ) * R . k li ( l1 , v ), li ( l2 , v ), li ( l3 , v ) \\left ( 0, \\quad - \\frac{8}{3}, \\quad 0\\right ) l1 , l2 , l3 \\left ( (2 t)\\mathbf{\\hat{j}_{R}}, \\quad (- 2 t + 2)\\mathbf{\\hat{j}_{R}} + (2 t)\\mathbf{\\hat{k}_{R}}, \\quad (- 2 t + 2)\\mathbf{\\hat{k}_{R}}\\right ) dl1 = diff ( l1 , t ) dl2 = diff ( l2 , t ) dl3 = diff ( l3 , t ) dl1 , dl2 , dl3 \\left ( (2)\\mathbf{\\hat{j}_{R}}, \\quad (-2)\\mathbf{\\hat{j}_{R}} + (2)\\mathbf{\\hat{k}_{R}}, \\quad (-2)\\mathbf{\\hat{k}_{R}}\\right ) voft ( l1 ), voft ( l2 ), voft ( l3 ) \\left ( \\mathbf{\\hat{0}}, \\quad (2 t \\left(- 4 t + 4\\right))\\mathbf{\\hat{j}_{R}}, \\quad \\mathbf{\\hat{0}}\\right ) voft ( l1 ) . dot ( l1 ), voft ( l2 ) . dot ( l2 ), voft ( l3 ) . dot ( l3 ) \\left ( 0, \\quad 2 t \\left(- 4 t + 4\\right) \\left(- 2 t + 2\\right), \\quad 0\\right ) integrate ( voft ( l2 ) . dot ( dl2 ),( t , 0 , 1 )) - \\frac{8}{3} A contour is a finite collection of paths joined end to end. A path can be represented as a continuous function form an closed iterval to \\mathbb{C} as follows \\gamma: [a~ b]\\subset \\mathbb{R} \\to \\mathbb{C}; \\quad \\gamma = \\gamma(t) Then the integration of any complex function along this path is is given by \\int_\\gamma f(z)dz = \\int_a^b f(t)~\\gamma'(t)~dt = \\sum_{i=1}^n f(t_i) \\left[\\gamma(t_i)-\\gamma(t_{i-1})\\right] Question: Find the integration of f(z)=z^2 along the parabolic path from 0 to 1 . Answer: In order to find the integration we have to find to parametrize the curve as \\gamma(t)=t+t^2i , t\\in [0,1] . % matplotlib inline import numpy as np from matplotlib import pyplot as plt x , y , t = symbols ( \"x y t\" ) def \u03b3 ( t ): return t + t ** 2 * 1j def f ( z ): return z * z # arr = np.linspace(0, 1, 10) # cnums = [\u03b3(t) for t in arr] # imgs = [f(z) for z in cnums] arr = np . linspace ( 0 , 1 , 10 ) # Y = np.linspace(0, 1, 10) X , Y = np . meshgrid ( arr , arr ) U = X ** 2 - Y ** 2 V = 2 * X * Y plt . quiver ( X , Y , U , V , edgecolor = 'k' , facecolor = 'None' , linewidth =. 5 ) cnums = np . array ( list ( map ( \u03b3 , arr ))) imgs = np . array ( list ( map ( f , cnums ))) X_0 = list ( map ( lambda z : z . real , cnums )) Y_0 = list ( map ( lambda z : z . imag , cnums )) U_0 = list ( map ( lambda z : z . real , imgs )) V_0 = list ( map ( lambda z : z . imag , imgs )) plt . plot ( X_0 , Y_0 , color = 'blue' ) plt . scatter ( X_0 , Y_0 , color = 'red' ) plt . quiver ( X_0 , Y_0 , U_0 , V_0 ) plt . show () # [(f(x+1j*y).real, f(x+1j*y).imag) for x in X for y in Y ] Here we will do the numerical computation \u0394 t = cnums [ 1 :] - cnums [: - 1 ] np . dot ( imgs [ 1 :], \u0394 t ) (-0.6818686799806022+0.675438053988273j) Now we do the same computation using integration integrate ( f ( \u03b3 ( t )) * diff ( \u03b3 ( t ), t ),( t , 0 , 1 )) -0.666666666666667 + 0.666666666666667 i import numpy as np from matplotlib import pyplot as plt from matplotlib import animation X , Y = np . mgrid [: 2 * np . pi : 10j ,: 2 * np . pi : 5j ] U = np . cos ( X ) V = np . sin ( Y ) fig , ax = plt . subplots ( 1 , 1 ) Q = ax . quiver ( X , Y , U , V , pivot = 'mid' , color = 'r' , units = 'inches' ) ax . set_xlim ( - 1 , 7 ) ax . set_ylim ( - 1 , 7 ) def update_quiver ( num , Q , X , Y ): \"\"\"updates the horizontal and vertical vector components by a fixed increment on each frame \"\"\" U = np . cos ( X + num * 0.1 ) V = np . sin ( Y + num * 0.1 ) Q . set_UVC ( U , V ) return Q # you need to set blit=False, or the first set of arrows never gets # cleared on subsequent frames anim = animation . FuncAnimation ( fig , update_quiver , fargs = ( Q , X , Y ), interval = 50 , blit = False ) fig . tight_layout () plt . show () import plotly.plotly as py from plotly.grid_objs import Grid , Column import time column_1 = Column ([ 0.9 , 1.1 ], 'x' ) column_2 = Column ([ 1.0 , 1.0 ], 'y' ) column_3 = Column ([ 0.8 , 1.2 ], 'x2' ) column_4 = Column ([ 1.2 , 0.8 ], 'y2' ) column_5 = Column ([ 0.7 , 1.3 ], 'x3' ) column_6 = Column ([ 0.7 , 1.3 ], 'y3' ) column_7 = Column ([ 0.6 , 1.4 ], 'x4' ) column_8 = Column ([ 1.5 , 0.5 ], 'y4' ) column_9 = Column ([ 0.4 , 1.6 ], 'x5' ) column_10 = Column ([ 1.2 , 0.8 ], 'y5' ) grid = Grid ([ column_1 , column_2 , column_3 , column_4 , column_5 , column_6 , column_7 , column_8 , column_9 , column_10 ]) py . grid_ops . upload ( grid , 'points_changing_size_grid' + str ( time . time ()), auto_open = False ) # create figure figure = { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x' ), 'ysrc' : grid . get_column_reference ( 'y' ), 'mode' : 'markers' , 'marker' : { 'color' : '#48186a' , 'size' : 10 } } ], 'layout' : { 'title' : 'Growing Circles' , 'xaxis' : { 'range' : [ 0 , 2 ], 'autorange' : False }, 'yaxis' : { 'range' : [ 0 , 2 ], 'autorange' : False }, 'updatemenus' : [{ 'buttons' : [ { 'args' : [ None ], 'label' : 'Play' , 'method' : 'animate' } ], 'pad' : { 'r' : 10 , 't' : 87 }, 'showactive' : False , 'type' : 'buttons' }]}, 'frames' : [ { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x2' ), 'ysrc' : grid . get_column_reference ( 'y2' ), 'mode' : 'markers' , 'marker' : { 'color' : '#3b528b' , 'size' : 25 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x3' ), 'ysrc' : grid . get_column_reference ( 'y3' ), 'mode' : 'markers' , 'marker' : { 'color' : '#26828e' , 'size' : 50 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x4' ), 'ysrc' : grid . get_column_reference ( 'y4' ), 'mode' : 'markers' , 'marker' : { 'color' : '#5ec962' , 'size' : 80 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x5' ), 'ysrc' : grid . get_column_reference ( 'y5' ), 'mode' : 'markers' , 'marker' : { 'color' : '#d8e219' , 'size' : 100 } } ] } ] } py . icreate_animations ( figure , 'points_changing_size' + str ( time . time ())) import plotly plotly . __version__ '3.7.0'","title":"Definition"},{"location":"Introduction/","text":"In this section we will define complex numbers as an extension of \\mathbb{R} as the following \\mathbb{C} \\cong \\mathbb{R}[x] / \\langle x^2+1 \\rangle = \\{a+bx+\\langle x^2+1 \\rangle\\ | ~ a,b \\in \\mathbb{R} \\} from sympy import * init_printing () a , b , c , d = symbols ( \"a b c d\" ) x , y = symbols ( \"x y\" ) Algebra of Complex Number \u00b6 Addition of two complex numbers are done as follows ad = ( a + b * x ) + ( c + d * x ) Eq ( ad , collect ( ad , x )) a + b x + c + d x = a + c + x \\left(b + d\\right) Multiplication is done as follows mul = ( a + b * x ) * ( c + d * x ) Eq ( mul , expand ( mul )) \\left(a + b x\\right) \\left(c + d x\\right) = a c + a d x + b c x + b d x^{2} irr = x ** 2 + 1 quo , rem = pdiv ( mul , irr ) collect ( rem , x ) a c - b d + x \\left(a d + b c\\right)","title":"Definition"},{"location":"Introduction/#algebra-of-complex-number","text":"Addition of two complex numbers are done as follows ad = ( a + b * x ) + ( c + d * x ) Eq ( ad , collect ( ad , x )) a + b x + c + d x = a + c + x \\left(b + d\\right) Multiplication is done as follows mul = ( a + b * x ) * ( c + d * x ) Eq ( mul , expand ( mul )) \\left(a + b x\\right) \\left(c + d x\\right) = a c + a d x + b c x + b d x^{2} irr = x ** 2 + 1 quo , rem = pdiv ( mul , irr ) collect ( rem , x ) a c - b d + x \\left(a d + b c\\right)","title":"Algebra of Complex Number"},{"location":"Plotting/","text":"% matplotlib inline import matplotlib.pyplot as plt from numpy import * ''' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~` This draws the axis for argand diagram ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~` ''' r = 1 # Y = [r*exp(1j*theta) for theta in linspace(0,2*pi, 200)] # Y = array(Y) # plt.plot(real(Y), imag(Y), 'r') plt . ylabel ( 'Imaginary' ) plt . xlabel ( 'Real' ) plt . axhline ( y = 0 , color = 'black' ) plt . axvline ( x = 0 , color = 'black' ) def argand ( complex_number , vector = False ): ''' This function takes a complex number. ''' z = complex_number x = real ( y ) y = imag ( y ) plt . plot ( x , y , 'bo' ) if vector : plt . quiver ( 0 , 0 , x , y ) # Draw the hypotenuse # plt.plot(x2,y2, 'r') # Draw the projection on real-axis plt . plot ( x , imag ( y ), 'bo' ) [ argand ( r * exp ( 1j * theta ), vector = True ) for theta in linspace ( 0 , 2 * pi , 10 )] plt . show () --------------------------------------------------------------------------- UnboundLocalError Traceback (most recent call last) &lt;ipython-input-40-501b6b9367ed&gt; in &lt;module&gt;() 38 plt.plot(real(y), imag(y), 'bo') 39 ---&gt; 40 [argand(r*exp(1j*theta), vector=True) for theta in linspace(0,2*pi,10)] 41 plt.show() &lt;ipython-input-40-501b6b9367ed&gt; in &lt;listcomp&gt;(.0) 38 plt.plot(real(y), imag(y), 'bo') 39 ---&gt; 40 [argand(r*exp(1j*theta), vector=True) for theta in linspace(0,2*pi,10)] 41 plt.show() &lt;ipython-input-40-501b6b9367ed&gt; in argand(complex_number, vector) 24 ''' 25 z = complex_number ---&gt; 26 x = real(y) 27 y = imag(y) 28 plt.plot(x,y, 'bo') UnboundLocalError: local variable 'y' referenced before assignment import matplotlib.pyplot as plt import numpy as np cnums = np . arange ( 5 ) + 1j * np . arange ( 6 , 11 ) X = [ x . real for x in cnums ] Y = [ x . imag for x in cnums ] plt . scatter ( X , Y , color = 'red' ) plt . show () a = [ 0. + 6.j , 1. + 7.j , 2. + 8.j , 3. + 9.j , 4. + 10.j ] for x in a : plt . polar ([ 0 , angle ( x )],[ 0 , abs ( x )], marker = 'o' ) Addition and Substraction \u00b6 import numpy as np import matplotlib.pyplot as plt soa = np . array ([[ 0 , 0 , 3 , 2 ], [ 0 , 0 , 1 , 2 ], [ 0 , 0 , 9 , 9 ]]) X , Y , U , V = zip ( * soa ) plt . figure () ax = plt . gca () ax . quiver ( X , Y , U , V , angles = 'xy' , scale_units = 'xy' , scale = 1 ) ax . set_xlim ([ - 1 , 10 ]) ax . set_ylim ([ - 1 , 10 ]) plt . draw () plt . show ()","title":"Plotting"},{"location":"Plotting/#addition-and-substraction","text":"import numpy as np import matplotlib.pyplot as plt soa = np . array ([[ 0 , 0 , 3 , 2 ], [ 0 , 0 , 1 , 2 ], [ 0 , 0 , 9 , 9 ]]) X , Y , U , V = zip ( * soa ) plt . figure () ax = plt . gca () ax . quiver ( X , Y , U , V , angles = 'xy' , scale_units = 'xy' , scale = 1 ) ax . set_xlim ([ - 1 , 10 ]) ax . set_ylim ([ - 1 , 10 ]) plt . draw () plt . show ()","title":"Addition and Substraction"}]}